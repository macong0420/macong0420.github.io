# 为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别
1.为什么代理要用weak？
   防止循环引用。例如View有一个协议，需要一个代理实现回调。一个Controller添加这个View，并且遵守协议，成为View的代理。如果不用week，用strong，Controller ->View -> delegate -> Controller，就循环引用了。

2.代理的delegate和dataSource有什么区别？
   delegate偏重于与用户交互的回调，有那些方法可以供我使用，例如UITableviewDelegate；dataSource偏重于数据的回调，view里面有什么东西，属性都是什么，例如UITableviewDatasource；

3.block和代理的区别?
首先共同点都是实现回调的方式。算了直白点说就是一个一对一，一个一对多。一个编写简单，一个实现繁复。
对于什么时候用block什么时候用代理简单来说就是公共接口，方法较多，回调类型较多可以选择用代理。对于异步和简单的回调用block好一点。
**block的优势**
  block的代码可读性更好。因为block只要实现就可以了，而代理需要遵守协议并且实现协议里的方法，而两者还不在一个地方。代理使用起来也更麻烦，因为要声明协议、声明代理属性、遵守协议、实现协议里的方法。block不需要声明，也不需要遵守，只需要声明属性和实现就可以了。
  block是一种轻量级的回调，可以直接访问上下文，由于block的代码是内联的，运行效率更高。block就是一个对象，实现了匿名函数的功能。所以我们可以把block当做一个成员变量、属性、参数使用，使用起来非常灵活。像用AFNetworking请求数据和GCD实现多线程，都使用了block回调。

**block劣势**
  blcok的运行成本高。block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是引用计数加1，使用完或者block置nil后才销毁。delegate只是保存了一个对象指针(一定要用week修饰delegate，不然也会循环引用)，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。
  block容易造成循环引用，而且不易察觉。因为为了blcok不被系统回收，所以我们都用copy关键字修饰，实行强引用。block对捕获的变量也都是强引用，所以就会造成循环引用。
  
**如何使用**
  优先使用block。
  如果回调的状态很多，多于三个使用代理。
  如果回调的很频繁，次数很多，像UITableview，每次初始化、滑动、点击都会回调，使用代理。
  block和代理都各有优缺点，所以我们一定要理解区分使用场景，应用适合的回调方式。优化APP的性能，提高流畅性，从点滴做起。

block 和 delegate 都可以通知外面。

block 更轻型，使用更简单，能够直接访问上下文，这样类中不需要存储临时数据，使用 block 的代码通常会在同一个地方，这样读代码也连贯。

delegate 更重一些，需要实现接口，它的方法分离开来，很多时候需要存储一些临时数据，另外相关的代码会被分离到各处，没有 block 好读。应该优先使用 block。

而有两个情况可以考虑 delegate。

 有多个相关方法。假如每个方法都设置一个 block, 这样会更麻烦。
 而 delegate 让多个方法分成一组，只需要设置一次，就可以多次回调。
 当多于 3 个方法时就应该优先采用 delegate。
     比如一个网络类，假如只有成功和失败两种情况，每个方法可以设计成单独 block。但假如存在多个方法，比如有成功、失败、缓存、https 验证，网络进度等等，这种情况下，delegate 就要比 block 要好。
 
 在 swift 中，利用 enum,  多个方法也可以合并成一个 block 接口。swift 中的枚举根据情况不同，可以关联不同数据类型。而在 objc 就不建议这样做，objc 这种情况下，额外数据需要使用 NSObject 或者 字典进行强转，接口就不够安全。
 
  为了避免循环引用，也可以使用 delegate。
  使用 block 时稍微不注意就形成循环引用，导致对象释放不了。这种循环引用，一旦出现就比较难检查出来。而 delegate 的方法是分离开的，并不会引用上下文，因此会更安全些。假如写一个库供他人使用，不清楚使用者的水平如何。这时为防止误用，宁愿麻烦一些，笨一些，使用 delegate 来替代 block。
  将 block 简单分类，有三种情形。
  * 临时性的，只用在栈当中，不会存储起来。比如数组的 foreach 遍历，这个遍历用到的 block 是临时的，不会存储起来。
  * 需要存储起来，但只会调用一次，或者有一个完成时期。比如一个 UIView 的动画，动画完成之后，需要使用 block 通知外面，一旦调用 block 之后，这个 block 就可以删掉。
  * 需要存储起来，可能会调用多次。比如按钮的点击事件，假如采用 block 实现，这种 block 就需要长期存储，并且会调用多次。调用之后，block 也不可以删除，可能还有下一次按钮的点击。
  * 对于临时性的，只在栈中使用的 block, 没有循环引用问题，block 会自动释放。
  * 而只调用一次的 block，需要看内部的实现，正确的实现应该是 block 调用之后，马上赋值为空，这样 block 也会释放，同样不会循环引用。
  * 而多次调用时，block 需要长期存储，就很容易出现循环引用问题。
  * Cocoa 中的 API 设计也是这样的，临时性的，只会调用一次的，采用 block。而多次调用的，并不会使用 block。比如按钮事件，就使用 target-action。有些库将按钮事件从 target-action 封装成 block 接口, 反而容易出问题。

参考:
[https://www.jianshu.com/p/6bba9b4a25d5]()
[https://blog.csdn.net/weixin_33787529/article/details/87255548]()
[https://www.zhihu.com/question/29023547/answer/109570584]()

